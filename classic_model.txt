/* C is modeling the cells of the tape of the Turing machine :
 * prev and next are link to form a sequence
 * main is a boolean indicating if the cell is attached or not to the tape
	* m is main
  * n is not main
 * com is a site that will communicate with the head on the tape
 * it is passed to the adjacent cell to trigger the move
 * shine s, u (s if yes, u otherwise)
*/
%agent: C(prev[C.next], next[C.prev], com[H.com_tape], main{m o}, val{t f}, shine{s u})


/* H is modeling the head which move on the tape :
 * com_tape is the link to the tape. 
 * com_aut is the link to the automata.
*/
%agent: H(com_tape[C.com], com_aut[S.com T.com])



/* S is modelling a particular state of the automata :
 * prev1, ..., prevn  (need of at most n transitions where n is the nb of states, but we can choose to put just as much as we need)
 * next0 and next1 are the two transitions departing from this states (considering that the alphabet have 2 letters, there are two transitions departing from each state)
 * com is the link to the head
 * id is the identifier of the node (will be useful during the construction of the automaton, during initialization)
 * Shine
	* s if yes
	* u if no
*/ 
%agent: S(prev1[T.next], prev2[T.next], prev3[T.next], 
prev4[T.next], prev5[T.next], prev6[T.next], 
next0[T.prev], next1[T.prev], com[H.com_aut], shine{s u})


/* T is modelling a transition between two states of the automata :
 * prev and next are the two links to the previous and next states
 * com is the link to the head
 * write contains the value that must be written on the tape
	* t is write t
	* f is write f
	* n is nothing
 * dep contains the deplacement of the head on the tape
	* l left
	* r right
	* n is nothing
 * shine (s) if it shines u otherwise.
*/
%agent: T(prev[S.next0 S.next1], next[S.prev1 S.prev2 S.prev3 S.prev4 S.prev5 S.prev6],
com[H.com_aut], write{t f}, dep{l r}, shine{s u})




/* tape rules
'elongation of the tape by the right' C(prev[.], main[1]), C(next[.], main[0]) -> C(prev[42], main[1]), C(next[42], main[1]) @ 1
'elongation of the tape by the left' C(prev[.], main[0]), C(next[.], main[1]) -> C([prev[42], main[1]), C(next[42], main[1]) @ 1

'pass move cell to cell 1' C(next[42], sig[0]), C(prev[42], shine[0]) -> C(next[42], sig[-1]), C(prev[42], shine[1]) @ 1
'pass move cell to cell 2' C(prev[42], sig[1]), C(next[42], shine[0]) -> C(prev[42], sig[-1]), C(next[42], shine[1]) @ 1
*/

/* head + tape rules 
'move head tape' H(com_tape[42]), C(com[42]), C(com[.], shine[1]) -> H(com_tape[42]), C(com[.]), C(com[42], shine[0]) @ 1

'write 0' H(com_tape[42], write[0]), C(com[42], val[#]) -> H(com_tape[42], write[-1]), C(com[42], val[0]) @1
'write 1' H(com_tape[42], write[1]), C(com[42], val[#]) -> H(com_tape[42], write[-1]), C(com[42], val[1]) @1

'pass move head to cell 1' H(com_tape[42], dep[0]), C(com[42], sig[#]) -> H(com_tape[42], dep[-1]), C(com[42], sig[0]) @ 1
'pass move head to cell 2' H(com_tape[42], dep[1]), C(com[42], sig[#]) -> H(com_tape[42], dep[-1]), C(com[42], sig[1]) @ 1

'read 0' H(com_tape[42], must_read[1], read[#]), C(com[42], val[0]) -> H(com_tape[42], must_read[0], read[0]), C(com[42], val[0]) @ 1
'read 1' H(com_tape[42], must_read[1], read[#]), C(com[42], val[1]) -> H(com_tape[42], must_read[0], read[1]), C(com[42], val[1]) @ 1 
*/

/* automaton + head rules
'ask reading' H(com_aut[42], must_read[0]), S(com[42], shine[1]) -> H(com_aut[42], must_read[1]), S(com[42], shine[0]) @ 1

'move head state' H(com_aut[42]), T(com[42]), S(com[.], shine[1]) ->  H(com_aut[42]), T(com[.]), S(com[42], shine[1]) @ 1
'move head transition' H(com_aut[42]), S(com[42]), T(com[.], shine[1]) -> H(com_aut[42]), S(com[.]), T(com[42], shine[1]) @ 1

'take read value 0' H(com_aut[42], must_read[0], read[0]), S(com[42], read[-1]) -> H(com_aut[42], must_read[0], read[0]), S(com[42], read[0]) @ 1
'take read value 1' H(com_aut[42], must_read[0], read[1]), S(com[42], read[-1]) -> H(com_aut[42], must_read[0], read[1]), S(com[42], read[1]) @ 1

'state to transition 0' S(read[0], next0[42]), T(prev[42], shine[0]) -> S(read[-1], next0[42]), T(prev[42], shine[1]) @ 1
'state to transition 1' S(read[1], next0[42]), T(prev[42], shine[0]) -> S(read[-1], next0[42]), T(prev[42], shine[1]) @ 1

'write value 0 + no deplacement' H(com_aut[42], write[-1]), T(com[42], write[0]) -> H(com_aut[42], write[0]), T(com[42], write[0]) @ 1
'write value 1 + no deplacement' H(com_aut[42], write[-1]), T(com[42], write[1]) -> H(com_aut[42], write[1]), T(com[42], write[1]) @ 1
'write value 0 + deplacement left' H(com_aut[42], write[-1], dep[-1]), T(com[42], write[0], dep[0]) -> H(com_aut[42], write[0], dep[0]), T(com[42], write[0], dep[0]) @ 1
'write value 1 + deplacement left' H(com_aut[42], write[-1], dep[-1]), T(com[42], write[1], dep[0]) -> H(com_aut[42], write[1], dep[0]), T(com[42], write[1], dep[0]) @ 1
'write value 0 + deplacement right' H(com_aut[42], write[-1], dep[-1]), T(com[42], write[0], dep[1]) -> H(com_aut[42], write[0], dep[1]), T(com[42], write[0], dep[1]) @ 1
'write value 1 + deplacement right' H(com_aut[42], write[-1], dep[-1]), T(com[42], write[1], dep[1]) -> H(com_aut[42], write[1], dep[1]), T(com[42], write[1], dep[1]) @ 1
*/

/* Initialization : To be done, according to a specified program for the Turing machine */


